---
title: 前端模块化规范及管理器
date: 2016-05-26 09:58:04
tags: 前端，模块化
---
模块化开发依然成为前端开发的主流，我们需要做的就是将不同的模块组织起来。最有名的前端模块管理器即requireJS，采用AMD标准。除此之外的其他模块管理器各有特色。
# 模块化规范
## CommonJS
CommonJS是服务器模块化的一种规范，NodeJS是其具体实现。加载模块是同步的。由于NodeJS主要用于服务器的编程，加载的模块文件一般已经存在本地，所以加载起来很快，不用考虑异步加载问题，而前端浏览器需要从服务器加载模块，则必须异步加载，就需要AMD，CDM。
CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}
 
- require()用来引入外部模块；
- exports对象用于导出当前模块的方法或变量，唯一的导出口；
- module对象就代表模块本身。

## AMD/CMD
**AMD**：异步模块定义，是RequireJS在推广过程中对模块定义的规范化产出 
**CMD**：通用模块定义，是SeaJS (由玉伯提出)在推广过程中对模块定义的规范化产出 
区别：
1. 对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。
2. CMD推崇依赖就近，AMD推崇依赖前置。**即SeaJS是懒执行，requireJS是预执行。**
- SeaJS只会在真正需要时才执行该模块，严格按照代码中require模块的顺序执行。
- RequireJS中所有依赖的模块加载被提前并行执行了，执行的顺序不能保证。这个问题使用shim参数就可以解决了，shim里面配置好依赖。

**官方的解释：**[SeaJS与RequireJS 的异同][1]



    //AMD 
    define(['./a','./b'], function (a, b) { 

        //依赖一开始就写好 
        a.test(); 
        b.test(); 
    }); 

    //CMD 
    define(function (requie, exports, module) { 
         
        //依赖可以就近书写 
        var a = require('./a'); 
        a.test(); 
         
        ... 
        //软依赖 
        if (status) { 
         
            var b = requie('./b'); 
            b.test(); 
        } 
    }); 
# 模块化管理器
## bower
主要用来进行模块的安装，升级和删除


    npm install -g bower
    bower install jquery
    bower update jquery
    bower uninstall jquery
## browserify
Browserify 是目前最常用的 CommonJS 格式转换的工具。本身也是一个NodeJS模块，可以通过npm来安装。使用类似NodeJS的require的方式来组织浏览器的javascript端代码。    

    npm install -g browserify


  [1]: https://github.com/seajs/seajs/issues/277